// Get leads assigned to current user (Manager and Staff only)
export const getMyLeads = query({
  args: {
    currentUserId: v.optional(v.union(v.id("users"), v.string())),
  },
  handler: async (ctx, args) => {
    try {
      // Validate currentUserId exists
      if (!args.currentUserId || args.currentUserId === "undefined" || args.currentUserId === "null") {
        return [];
      }

      // Validate it's a proper ID format using normalizeId
      const normalizedUserId = ctx.db.normalizeId("users", args.currentUserId);
      if (!normalizedUserId) {
        // If it's not a valid ID, we can't fetch the user
        return [];
      }

      let currentUser: any = null;
      try {
        currentUser = await ctx.db.get(normalizedUserId);
      } catch (error) {
        console.error("Error fetching user in getMyLeads:", error);
        return [];
      }
      
      if (!currentUser) {
        return [];
      }

      // Admin users should not use this query
      if (currentUser.role === ROLES.ADMIN) {
        return [];
      }

      let leads: any[] = [];
      try {
        leads = await ctx.db
          .query("leads")
          .withIndex("assignedTo", (q) => q.eq("assignedTo", currentUser._id))
          .collect();
      } catch (error) {
        console.error("Error querying leads by index:", error);
        // Fallback to full table scan if index fails
        try {
          const all = await ctx.db.query("leads").collect();
          leads = all.filter((l) => String(l.assignedTo ?? "") === String(currentUser._id));
        } catch (fallbackError) {
          console.error("Fallback query also failed:", fallbackError);
          return [];
        }
      }

      // Filter out not relevant leads
      leads = leads.filter((l) => l.status !== LEAD_STATUS.NOT_RELEVANT);

      // Sort by lastActivityTime (most recent first), fallback to _creationTime
      leads.sort((a, b) => {
        const aTime = a.lastActivityTime ?? a._creationTime;
        const bTime = b.lastActivityTime ?? b._creationTime;
        return bTime - aTime; // Descending order (newest first)
      });
      
      return leads;
    } catch (err) {
      console.error("getMyLeads outer error:", err);
      return [];
    }
  },
});

export const deleteTemplate = action({
  args: {
    templateId: v.id("whatsappTemplates"),
    name: v.string(),
  },
  handler: async (ctx, args) => {
    try {
      // First verify the template exists
      let template;
      try {
        template = await ctx.runQuery(internal.whatsappTemplates.getTemplateInternal, {
          templateId: args.templateId,
        });
      } catch (err) {
        console.error("Error fetching template internal:", err);
        throw new Error("Failed to verify template existence");
      }

      if (!template) {
        // If template is already gone from DB, consider it success or throw specific error
        console.log("Template not found in database, might be already deleted");
        return { success: true };
      }

      const token = process.env.WHATSAPP_ACCESS_TOKEN;
      const wabaId = process.env.WHATSAPP_BUSINESS_ACCOUNT_ID;
      const version = process.env.CLOUD_API_VERSION || "v21.0";

      if (!token || !wabaId) {
        console.error("Missing WhatsApp credentials");
        throw new Error("Missing WhatsApp credentials. Please check your environment variables.");
      }

      console.log(`[WhatsApp] Deleting template from Meta: ${args.name}`);

      try {
        const response = await fetch(
          `https://graph.facebook.com/${version}/${wabaId}/message_templates?name=${encodeURIComponent(args.name)}`,
          {
            method: "DELETE",
            headers: {
              Authorization: `Bearer ${token}`,
            },
          }
        );

        const data = await response.json();

        if (!response.ok) {
          console.error("[WhatsApp] Template deletion from Meta failed:", data);
          // If template doesn't exist on Meta (already deleted), we can still delete from DB
          if (data.error?.code === 100 || data.error?.message?.includes("does not exist")) {
            console.log("[WhatsApp] Template not found on Meta, deleting from DB only");
          } else {
            // Log but don't block DB deletion if it's a permission issue or something else
            console.warn("Failed to delete from Meta, but proceeding to delete from DB:", data.error?.message);
          }
        } else {
          console.log("[WhatsApp] Template deleted from Meta successfully");
        }

        // Delete from DB
        await ctx.runMutation(internal.whatsappTemplates.deleteTemplateInternal, {
          templateId: args.templateId,
        });

        return { success: true };

      } catch (error: any) {
        console.error("[WhatsApp] Delete exception:", error);
        throw new Error(`Delete failed: ${error.message}`);
      }
    } catch (error: any) {
      console.error("[WhatsApp] Delete template error:", error);
      // Return a structured error if possible, or throw a clean error
      throw new Error(`Failed to delete template: ${error.message}`);
    }
  },
});

async function findDuplicateLead(ctx: any, mobileNo: string, email: string) {
  if (!args.currentUserId || args.currentUserId === "undefined" || args.currentUserId === "null") {
    return [];
  }

  // Validate it's a proper ID format using normalizeId
  const normalizedUserId = ctx.db.normalizeId("users", args.currentUserId);
}

<DialogHeader className="px-6 py-4 border-b flex flex-row items-center justify-between space-y-0 bg-white shrink-0">
  <div className="flex items-center gap-4">
    <DialogTitle className="text-xl font-bold text-gray-800">WhatsApp Templates</DialogTitle>
    <DialogDescription className="sr-only">Manage your WhatsApp templates</DialogDescription>
    <Badge variant="secondary" className="hidden sm:flex bg-blue-50 text-blue-700 hover:bg-blue-100">
      <span className="flex items-center gap-2">
        <span className="text-sm font-medium">WhatsApp Templates</span>
        <span className="text-xs text-blue-500">Manage</span>
      </span>
    </Badge>
  </div>
</DialogHeader>